// WE PULL THIS CONTENT FROM https://github.com/aporeto-inc/junon
// DO NOT EDIT THIS FILE.
// YOU MUST SUBMIT A PR AGAINST THE UPSTREAM REPO.
// THE UPSTREAM REPO IS CURRENTLY PRIVATE.

== Basic concepts

=== Segment Console

Segment Console is a micro-service application designed for scale that
manages all Segment resources. You can access it from three interfaces.

* *Web interface*: a web application accessed through your browser that
allows you to define all resources, as well as view a visual
representation of all applications that are protected by Segment. All
possible actions in the web interface may be alternatively performed by
scripts instead.
* *Command line*: `apoctl` is the Segment command line interface (CLI).
It supports completion as well as various other commands that will help
you automate everything in Segment.
* *REST API*: the Segment Console API allows programmatic manipulation
of all parts of the system. Both the web interface and `apoctl` act as
clients of the Segment Console API.

=== Tags and identity

==== Basics

In order to understand how Segment secures your system, you have to
understand how it handles object identity. The identity of an object is
established by a set of tags and a tag is a key-value pair that
describes an attribute of an object.

For example:

* `app=wordpress`
* `role=frontend`
* `env=qa`
* `os=linux`
* `$type=docker`

Tags are consumed from different sources like the computing environment,
the application, or Segment Console itself. Other tags can be added
manually using the Segment Console web interface, from the command line
with `apoctl`, or a Segment Console API call. This powerful tag-based
identity is used to define network policies and API authorizations in
Segment.

==== Types of tags

Tag names are categorized and prefixed based on their origin.

[width="100%",cols="<10%,<67%,<23%",options="header",]
|===
|Prefix |Description |Example
|`$` |*Attribute based tag*: auto-generated, based on object attributes.
|`$name=nginx`

|`@` |*Metadata Tag*: can only be added at the creation.
|`@sys:image=nginx`

|`@auth` |*Auth Tag*: derived from an auth token claim
|`@auth:account=mycompany`

| |*User Defined*: defined by a user |`role=frontend`
|===

==== Tag expressions

You can link tags together with `AND` or `OR` operators to form tag
expressions.

For example, you can create an expression like:

[source,bash]
----
(size=big and color=blue) or (size=small and color=red) or (type=admin)
----

Segment represents this information in a two-dimensional array, where:

* The first dimension is `OR`s
* The second dimension is `AND`s

The above expression is then represented by:

[source,json]
----
[
  ["size=big", "color=blue"],
  ["size=small", "color=red"],
  ["type=admin"],
]
----

The web interface provides graphical controls to help you build these
expressions easily.

==== Best practices

It may be tempting to add a large number of tags, but in reality,
remember the adage ``less is more.'' In the end, adding a large number
of tags may be more confusing than it is helpful.

For example, if you deploy a three-tier application, you may only need:

* `app=myapp`
* `role=frontend`, `role=backend`, `role=database`
* `env=production`

In turn, you can create a network policy that will allow:

* allow from `app=myapp and role=frontend and env=production` to
`app=myapp and role=backend and env=production`
* allow from `app=myapp and role=backend and env=production` to
`app=myapp and role=database and env=production`

=== Authentication

Authentication is the process or action of verifying the identity of a
user or process. For example, it might be seen as an ID card claiming
who the caller is to a system.

Segment Console authentication is based on
https://tools.ietf.org/html/rfc7519[JSON Web Tokens (JWT)]. JWTs are an
open, industry standard method for representing claims securely between
two parties. These tokens are issued by Segment Console as long as it
can verify the provenance. The token is used with almost all API
requests to Segment Console.

=== Authorization

==== Basics

Once Segment Console knows the identity of the caller, it will check the
API authorizations to decide if the user is allowed to perform the
operation or not.

API authorizations use a tag expression that is based on the claim’s
`data` field as a subject to assign roles to the caller. Roles contain a
list of allowed resources and operations.

For instance, the role `Namespace Administrator` gives full read/write
permissions on a namespace while the role `Enforcer` only gives
permissions necessary for a Defender to work properly.

Reusing the above examples it is possible to create the following API
authorizations. As you can see below, the content of the tags in the
subject field are coming from the `data` section of the JWT. They must
be converted to `@auth:<lower-case-key>=<value>` to avoid any confusion
with other tags.

==== Make the Aporeto company account administrator a namespace administrator

The following API authorization makes the user, coming with a token for
the account ``company'', an administrator on the namespace
`/mynamespace` and all the child namespaces.

[cols="<,<",options="header",]
|===
|field |description
|subject |`@auth:realm=vince` and `@auth:account=company`
|object |`@auth:role=namespace.administrator`
|namespace |`/acme`
|propagate |`true`
|===

`@auth:realm=vince` indicates that the token is coming from an Aporeto
account.

==== Make the AWS security token bearer a Defender

The following API authorization makes the user, coming with a token from
AWS that has the role `segment`, a Defender on the namespace
`/acme/app/gitlab` only.

[cols="<,<",options="header",]
|===
|field |description
|subject |`@auth:realm=awssecuritytoken` and `@auth:rolename=segment`
|object |`@auth:role=enforcer`
|namespace |`/acme/app/gitlab`
|===

=== Defender

The Defender is an agent that runs on your deployed server and applies
any policies which you have defined in Segment Console. Once deployed,
the Defender connects to the Segment Console API using credentials just
as any other client does, and it is bound to API authorizations. The
role of the Defender agent is to protect any unit of computation called
*processing units*.

image::enforcer-policy-pcc.png[Protection diagram]

The Defender can protect traffic between two processing units at
different layers of the network stack. At layer 3, it automatically adds
the processing unit’s cryptographically signed identity during the
`SYN/SYN->ACK` portion of TCP session establishment (or by using UDP
options in the case of UDP traffic). At layer 4, it exchanges identities
after a TCP connection is established, but before any data traffic is
allowed to flow. In this case, it utilizes
https://tools.ietf.org/html/rfc7413[TCP Fast Open] to minimize the
round-trip times needed to complete a robust authorization.

The addition of these cryptographically signed tags allows Segment to
exchange and verify the identity of both processing units and validate
if there is a network policy which will allow or deny traffic between
the two endpoints. Once the authentication and authorization is
complete, the Defender allows both processing units to communicate
directly.

At layer 7, the Defender operates as a full API proxy and injects
authorization information on every API call. In this case, it can
perform per API endpoint authorization between processing units as well
as between users and processing units.

image::enforcer-tcp-pcc.png[Enforcement]

The content of traffic is never visible to Segment Console or the
Defender. The Defender’s role is to allow or drop the connection
establishment depending on policies it has received from Segment
Console.

The Defender can be installed as a:

* Kubernetes DaemonSet
* Docker container
* Linux `systemd` service

=== Processing units

A processing unit represents a unit of computation which the Defender
will protect by applying network policies. It can be:

* A container
* A Kubernetes pod
* A Linux process
* An entire Linux host
* Specific services (protocol/port pairs) in a Linux host

The Defender reports the processing units and the network interactions
it protects to Segment Console so you can visualize your application
flows.

It will apply default tags to the processing units according to what it
finds. For example, a container will be tagged with the image name, a
process with its PID, a host with its hostname, a pod with its
namespace, and so on. This set of predictable tags can be used to write
network policies.

image::pus.png[Processing units]

=== External networks

An external network refers to anything that is not protected by a
Defender and still needs to be accessed using the basic access control
lists. Like any other object, tags can be associated to an external
network so it can be used in a policy.
