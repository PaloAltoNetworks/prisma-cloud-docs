== Serverless Defender

Serverless Defender protects serverless functions at runtime.
It monitors your functions to ensure they execute as designed.

Per-function policies let you control:

* Process activity.
Enables verification of launched subprocesses against policy.

* Network connections.
Enables verification of inbound and outbound connections, and permits outbound connections to explicitly allowed domains.

* File system activity.
Controls which parts of the file system functions can access.

Currently, Prisma Cloud supports AWS Lambda functions.
The following runtimes are supported:

* C# (.NET Core) 2.1, 3.1
* Java 8, 11
* Node.js 10.x, 12.x, 14.x
* Python 2.7, 3.6, 3.7, 3.8
* Ruby 2.5, 2.7

// To be fixed in Fermat
// https://github.com/twistlock/twistlock/issues/18563
NOTE: Currently, only users with the Administrator role can see the list of deployed Serverless Defenders in *Manage > Defenders > Manage*.


=== Securing serverless functions

To secure an AWS Lambda function, embed the Prisma Cloud Serverless Defender into it.
The steps are:

. (Optional) If you are not using a deployment framework like SAM or Serverless Framework, download a ZIP file that contains your function source code and dependencies.

. Embed the Serverless Defender into the function.

. Deploy the new function or upload the updated ZIP file to AWS.

. Define a serverless protection runtime policy.

. Define a serverless WAAS policy.


[.task]
=== (Optional) Download your function as a ZIP file

Download your function's source code from AWS as a ZIP file.

[.procedure]
. From Lambda's code editor, click *Actions > Export function*.

. Click *Download deployment package*.
+
Your function is downloaded to your host as a ZIP file.

. Create a working directory, and unpack the ZIP file there.
+
In the next step, you'll download the Serverless Defender files to this working directory.


[.task]
=== Embed Serverless Defender into C# functions

In your function code, import the Serverless Defender library and create a new protected handler that wraps the original handler.
The protected handler will be called by AWS when your function is invoked.
Update the project configuration file to add Prisma Cloud dependencies and package references.

Prisma Cloud supports .NET Core 2.1 and 3.1.

[.procedure]
. Open Compute Console, and go to *Manage > Defenders > Deploy > Single Defender*.

ifdef::compute_edition[]
. Choose the DNS name or IP address Serverless Defender uses to connect to Console.
endif::compute_edition[]

ifdef::prisma_cloud[]
. The DNS name Serverless Defender uses to connect to your Compute Console is prepopulated for you.
endif::prisma_cloud[]

. In *Choose Defender type*, select *Serverless*.

. In *Runtime*, select *C#*.

. Download the Serverless Defender package to your workstation.

. Unzip the Serverless Defender bundle into your working directory.

. Embed the serverless Defender into the function by importing the Prisma Cloud library and wrapping the function's handler.
+
Function input and output can be a struct or a stream.
Functions can be synchronous or asynchronous.
The context parameter is optional in .NET, so it can be omitted.
+
[source]
----
  using Twistlock;

  public class ... {
      // Original handler
      public ApplicationLoadBalancerResponse Handler(ApplicationLoadBalancerRequest request, ILambdaContext context)
      {
        ...
      }

      // Application load balancer example
      // Twistlock protected handler
      public ApplicationLoadBalancerResponse ProtectedHandler(ApplicationLoadBalancerRequest request, ILambdaContext context)
      {
          return Twistlock.Serverless.Handler<ApplicationLoadBalancerRequest, ApplicationLoadBalancerResponse>(Handler, request, context);
      }
      ...
  }
----

. Add the Twistlock package as a dependency in your nuget.config file.
+
If a nuget.config file doesn't exist, create one.

  <configuration>
    <packageSources>
      <add key="local-packages" value="./twistlock"/>
    </packageSources>
  </configuration>

. Reference the Twistlock package in your csproj file.

  <Project>
    <ItemGroup>
      <PackageReference Include="Twistlock" Version="19.11.462"/>
      <TwistlockFiles Include="twistlock/*" Exclude="twistlock/twistlock.19.11.462.nupkg"/>
    </ItemGroup>
    <Target Name="CopyCustomContentOnPublish" AfterTargets="Publish">
      <Copy SourceFiles="@(TwistlockFiles)" DestinationFolder="$(PublishDir)/twistlock"/>
    </Target>
    .
    .
    .
  </Project>

. Generate the value for the TW_POLICY environment variable by specifying your function's name and region.
+
NOTE: If *Any* is selected for region, only policies that contain *** in the region label will be matched.
+
Serverless Defender uses TW_POLICY to determine how to connect to Compute Console to retrieve policy and send audits.
+
Copy the value generated for TW_POLICY, and set it aside.

. xref:_upload_the_protected_function_to_aws[Upload the protected function to AWS, and set the TW_POLICY environment variable.]


[.task]
=== Embed Serverless Defender into Java functions

To embed Serverless Defender, import the Twistlock package and update your code to start Serverless Defender as soon as the function is invoked.
Prisma Cloud supports both Maven and Gradle projects.
You'll also need to update your project metadata to include Serverless Defender dependencies.

Prisma Cloud supports https://docs.aws.amazon.com/lambda/latest/dg/java-handler-using-predefined-interfaces.html[both predefined interfaces] in the AWS Lambda Java core library: RequestStreamHandler (where input must be serialized JSON) and RequestHandler.

AWS lets you specify handlers as functions or classes.
In both cases, Twistlock.Handler(), the entry point to Serverless Defender, assumes the entry point to your code is named handleRequest.
After embedding Serverless Defender, update the name of the handler registered with AWS to be the wrapper method that calls Twistlock.Handler() (for example, protectedHandler).

Prisma Cloud supports both service struct and stream input (serialized struct).
Even though the Context parameter is optional for unprotected functions, it's manadatory when embedding Serverless Defender.

Prisma Cloud supports Java 8 and Java 11.

[.procedure]
. Open Compute Console, and go to *Manage > Defenders > Deploy > Single Defender*.

ifdef::compute_edition[]
. Choose the DNS name or IP address Serverless Defender uses to connect to Console.
endif::compute_edition[]

ifdef::prisma_cloud[]
. The DNS name Serverless Defender uses to connect to your Compute Console is prepopulated for you.
endif::prisma_cloud[]

. In *Choose Defender type*, select *Serverless*.

. In *Runtime*, select *Java*.

. In *Package*, select *Maven* or *Gradle*.
+
The steps for embedding Serverless Defender differ depending on the build tool.

. Download the Serverless Defender package to your workstation.

. Unzip the Serverless Defender bundle into your working directory.

. Embed Serverless Defender into your function by importing the Prisma Cloud package and wrapping the function's handler.
+
[source]
----
import com.twistlock.serverless.Twistlock;

public class ... implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {

  // Original handler
  @Override
  public APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent request, Context context) {
  {
    ...
  }

  // RequestHandler example
  // Twistlock protected handler
  public APIGatewayProxyResponseEvent protectedHandler(APIGatewayProxyRequestEvent request, Context context) {
    return Twistlock.Handler(this, request, context);
  }
  ...
}
...
----

. Update your project configuration file.

.. *Maven*
+
Update your pom.xml file.
Don't create new sections for the Prisma Cloud configurations.
Just update existing sections.
For example, don't create a new <plugins> section if one exists already.
Just append a <plugin> section to it.
+
Add the assembly plugin to include the Twistlock package in the final function JAR.
Usually the shade plugin is used in AWS to include packages to standalone JARs, but it doesn't let you include local system packages.
+
  <project>
    <build>
      <!-- Add assembly plugin to create a standalone jar that contains Twistlock library -->
      <plugins>
        <plugin>
          <artifactId>maven-assembly-plugin</artifactId>
          <configuration>
            <appendAssemblyId>false</appendAssemblyId>
            <descriptors>
              <descriptor>assembly.xml</descriptor>
            </descriptors>
          </configuration>
          <executions>
            <execution>
             <id>make-assembly</id>
             <phase>package</phase>
             <goals>
              <goal>attached</goal>
             </goals>
            </execution>
          </executions>
        </plugin>
        ...
      </plugins>
+
      <!-- Add Twistlock resources -->
      <resources>
        <resource>
          <directory>${project.basedir}</directory>
          <includes>
            <include>twistlock/*</include>
            </includes>
          <excludes>
            <exclude>twistlock/*.jar</exclude>
          </excludes>
        </resource>
        ...
      </resources>
      ...
    </build>
+
    <!-- Add Twistlock package reference -->
    <dependencies>
      <dependency>
        <groupId>com.twistlock.serverless</groupId>
        <artifactId>twistlock</artifactId>
        <version>19.11.462</version>
        <scope>system</scope>
        <systemPath>${project.basedir}/twistlock/twistlock-19.11.462.jar</systemPath>
      </dependency>
      ...
    </dependencies>
    ...
  </project>

.. Create an assembly.xml file, which packs all dependencies in a standalone JAR.

  <assembly>
    <id>twistlock-protected</id>
    <formats>
      <format>jar</format>
    </formats>
    <includeBaseDirectory>false</includeBaseDirectory>
    <dependencySets>
      <!-- Unpack runtime dependencies into runtime jar -->
      <dependencySet>
        <unpack>true</unpack>
        <scope>runtime</scope>
      </dependencySet>
      <!-- Unpack local system dependencies into runtime jar -->
      <dependencySet>
        <unpack>true</unpack>
        <scope>system</scope>
      </dependencySet>
    </dependencySets>
  </assembly>

. *Gradle*
+
Update your build.gradle file.

.. Add Twistlock package reference in the project configuration file i.e build.gradle
+
[source]
----
dependencies {
    compile (
        files('twistlock/twistlock-19.11.462.jar')
    )
}

task buildZip(type: Zip) {
    from compileJava
    from processResources
    into('lib') {
        from configurations.runtimeClasspath
    }
    // Include Twistlock dependencies
    into ('twistlock') {
        from 'twistlock'
        exclude "*.jar"
    }
}

build.dependsOn buildZip
----

. In AWS, set the name of the Lambda handler for your function to protectedHandler.

. Generate the value for the TW_POLICY environment variable by specifying your function's name and region.
+
NOTE: If *Any* is selected for region, only policies that contain *** in the region label will be matched.
+
Serverless Defender uses TW_POLICY to determine how to connect to Compute Console to retrieve policy and send audits.
+
Copy the value generated for TW_POLICY, and set it aside.

. xref:_upload_the_protected_function_to_aws[Upload the protected function to AWS, and set the TW_POLICY environment variable.]


[.task]
=== Embed Serverless Defender into Node.js functions

Import the Serverless Defender module, and configure your function to start it.
Prisma Cloud supports Node.js 10.x, 12.x, and 14.x.

[.procedure]
. Open Compute Console, and go to *Manage > Defenders > Deploy > Single Defender*.

ifdef::compute_edition[]
. Choose the DNS name or IP address Serverless Defender uses to connect to Console.
endif::compute_edition[]

ifdef::prisma_cloud[]
. The DNS name Serverless Defender uses to connect to your Compute Console is prepopulated for you.
endif::prisma_cloud[]

. In *Choose Defender type*, select *Serverless*.

. In *Runtime*, select *Node.js*.

. Download the Serverless Defender package to your workstation.

. Unzip the Serverless Defender bundle into your working directory.

. Embed the serverless Defender into the function by importing the Prisma Cloud library and wrapping the function's handler.

.. For asynchronous handlers:

  // Async handler
  var twistlock = require('./twistlock');
  exports.handler = async (event, context) => {
  .
  .
  .
  };
  exports.handler = twistlock.asyncHandler(exports.handler);

.. For synchronous handlers:

  // Non-async handler
  var twistlock = require('./twistlock');
  exports.handler = (event, context, callback) => {
  .
  .
  .
  };
  exports.handler = twistlock.handler(exports.handler);

. Generate the value for the TW_POLICY environment variable by specifying your function's name and region.
+
NOTE: If *Any* is selected for region, only policies that contain *** in the region label will be matched.
+
Serverless Defender uses TW_POLICY to determine how to connect to Compute Console to retrieve policy and send audits.
+
Copy the value generated for TW_POLICY, and set it aside.

. xref:_upload_the_protected_function_to_aws[Upload the protected function to AWS, and set the TW_POLICY environment variable.]
* Prisma Cloud Serverless Defender includes native node.js libraries. If you are using webpack, please refer to tools such as https://www.npmjs.com/package/native-addon-loader[native-addon-loader] to make sure these libraries are included in the function ZIP file.


[.task]
=== Embed Serverless Defender into Python functions

Import the Serverless Defender module, and configure your function to invoke it.
Prisma Cloud supports Python 2.7, 3.6, 3.7, and 3.8.

[.procedure]
. Open Compute Console, and go to *Manage > Defenders > Deploy > Single Defender*.

ifdef::compute_edition[]
. Choose the DNS name or IP address Serverless Defender uses to connect to Console.
endif::compute_edition[]

ifdef::prisma_cloud[]
. The DNS name Serverless Defender uses to connect to your Compute Console is prepopulated for you.
endif::prisma_cloud[]

. In *Choose Defender type*, select *Serverless*.

. In *Runtime*, select *Python*.

. Download the Serverless Defender package to your workstation.

. Unzip the Serverless Defender bundle into your working directory.

. Embed the serverless Defender into the function by importing the Prisma Cloud library and wrapping the function's handler.

  import twistlock.serverless
  @twistlock.serverless.handler
  def handler(event, context):
  .
  .
  .

. Generate the value for the TW_POLICY environment variable by specifying your function's name and region.
+
NOTE: If *Any* is selected for region, only policies that contain *** in the region label will be matched.
+
Serverless Defender uses TW_POLICY to determine how to connect to Compute Console to retrieve policy and send audits.
+
Copy the value generated for TW_POLICY, and set it aside.

. xref:_upload_the_protected_function_to_aws[Upload the protected function to AWS, and set the TW_POLICY environment variable.]



[.task]
=== Embed Serverless Defender into Ruby functions

Import the Serverless Defender module, and configure your function to invoke it.
Prisma Cloud supports Ruby 2.5 and 2.7.

[.procedure]
. Open Compute Console, and go to *Manage > Defenders > Deploy > Single Defender*.

ifdef::compute_edition[]
. Choose the DNS name or IP address Serverless Defender uses to connect to Console.
endif::compute_edition[]

ifdef::prisma_cloud[]
. The DNS name Serverless Defender uses to connect to your Compute Console is prepopulated for you.
endif::prisma_cloud[]

. In *Choose Defender type*, select *Serverless*.

. In *Runtime*, select *Ruby*.

. Download the Serverless Defender package to your workstation.

. Unzip the Serverless Defender bundle into your working directory.

. Embed the serverless Defender into the function by importing the Prisma Cloud library and wrapping the function's handler.

.. Option 1:
+
----
require_relative './twistlock/twistlock'
def handler(event:, context:)
    Twistlock.handler(event: event, context: context) { |event:, context:|
        # Original handler
        ...
    }
end
.
.
.
----
 
.. Option 2:
+
----
require_relative './twistlock/twistlock'
# Handler as a class method
module Module1
    class Class1
        def self.original_handler(event:, context:)
            ...
        end
        def self.protected_handler(event:, context:)
            return Twistlock.handler(event: event, context: context, &method(:original_handler))
        end
    end
end
.
.
.
----

. Generate the value for the TW_POLICY environment variable by specifying your function's name and region.
+
NOTE: If *Any* is selected for region, only policies that contain *** in the region label will be matched.
+
Serverless Defender uses TW_POLICY to determine how to connect to Compute Console to retrieve policy and send audits.
+
Copy the value generated for TW_POLICY, and set it aside.

. xref:_upload_the_protected_function_to_aws[Upload the protected function to AWS, and set the TW_POLICY environment variable.]


[.task, #_upload_the_protected_function_to_aws]
=== Upload the protected function to AWS

After embedding Serverless Defender into your function, upload it to AWS. If you are using a deployment framework such as SAM or Serverless Framework just deploy the function with your standard deployment procedure. If you are using AWS directly, follow the steps below:

[.procedure]
. Upload the new ZIP file to AWS.

.. In *Designer*, select your function so that you can view the function code.

.. Under *Code entry type*, select *Upload a .ZIP file*.

.. Specify a runtime and the handler.
+
Validate that *Runtime* is a supported runtime, and that *Handler* points to the function's entry point.

.. Click *Upload*.
+
image::install_serverless_defender_upload_zip.png[width=800]

.. Click *Save*.

. Set the TW_POLICY environment variable.

..  In Designer, open the environment variables panel.

.. For Key, enter TW_POLICY.

.. For Value, paste the rule you copied from Compute Console.

.. Click Save.


[.task]
[#_defining_policy]
=== Defining your runtime protection policy

By default, Prisma Cloud ships with an empty serverless runtime policy.
An empty policy disables runtime defense entirely.

You can enable runtime defense by creating a rule.
By default, new rules:

* Apply to all functions (`{asterisk}`), but you can target them to specific functions by function name.
* Block all processes from running except the main process.
This protects against command injection attacks.

When functions are invoked, they connect to Compute Console and retrieve the latest policy.
To ensure that functions start executing at time=0 with your custom policy, you must predefine the policy.
Predefined policy is embedded into your function along with the Serverless Defender by way of the `TW_POLICY` environment variable.

// To minimize the impact on start latency, the customer's business logic is allowed to asynchronously start executing while the policy
// is downloaded in the background. The sequence of events is:
//
// 1. Start the Serverless Defender
// 2. Download policy, if necessary
// 3. Run customer's handler
//
// Steps 2 and 3 are asynchronous (3 can start before 2 finishes). For this reason, it's important to define policy before embedding
// the `TW_POLICY` env var into the function.
//
// For more info: see the discussion in https://github.com/twistlock/docs/pull/1227/files
//
// Customers will be able to select between synchronous (more secure) and ansynchronous (more performant) policy download soon.
// See:  https://github.com/twistlock/twistlock/issues/16608

[.procedure]
. Log into Prisma Cloud Console.

. Go to *Defend > Runtime > Serverless Policy*.

. Click *Add rule*.

. In the *General* tab, enter a rule name.

. (Optional) Target the rule to specific functions.
+
In *Functions*, enter a function name.
Use xref:../../configure/rule_ordering_pattern_matching.adoc[pattern matching] to refine how the rule is applied.

. Set the rule parameters in the  *Processes*, *Networking*, and *File System* tabs.

. Click *Save*.

[.task, #_defining_cnaf_policy]
=== Defining your serverless WAAS policy

Prisma Cloud lets you protect your serverless functions against application layer attacks by utlizing the serverless xref:../../waas/waas.adoc[Web Application and API Security (WAAS)].

By default, the serverless WAAS is disabled.
To enable it, add a new serverless WAAS rule.

[.procedure]
. Log into Prisma Cloud Console.

. Go to *Defend > WAAS > Serverless*.

. Click *Add rule*.

. In the *General* tab, enter a rule name.

. (Optional) Target the rule to specific functions.
+
In *Functions*, enter a function name.
Use xref:../../configure/rule_ordering_pattern_matching.adoc[pattern matching] to refine how the rule is applied.

. Set the protections you want to apply (*SQLi*, *CMDi*, *Code injection*, *XSS*, *LFI*).

. Click *Save*.
