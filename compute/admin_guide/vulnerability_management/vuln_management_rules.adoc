== Vulnerability management rules

Vulnerability policies are composed of discrete rules.
Rules declare the actions to take when vulnerabilities are found in the resources in your environment.
They also control the data surfaced in Prisma Cloud Console, including scan reports and Radar visualizations.

Rules let you target segments of your environment and specify actions to take when vulnerabilities of a given type are found.
For example:

{nbsp}{nbsp}{nbsp} _Block images with critical severity vulnerabilities from being deployed to prod environment hosts_

When there is no matching rule for vulnerability scanning on specific resources such as an image or a function, Prisma Cloud generates alerts on all vulnerabilities that are found.

There are separate vulnerability policies for containers, hosts, and serverless functions.
Host and serverless rules offer a subset of the capabilities of container rules, the big difference being that container rules support blocking.


[.task]
=== Creating vulnerability rules

Prisma Cloud ships with a simple default vulnerability policy for containers, hosts, and serverless functions.
These policies have a rule named _Default - alert all components_, which sets the alert threshold to low.
With this rule, all vulnerabilities in images, hosts, and functions are reported.

As you build out your policy, you'll create rules that filter out insignificant information, such as low severity vulnerabilities, and surface vital information, such as critical vulnerabilities.

xref:../configure/rule_ordering_pattern_matching.adoc#_rule_order[Rule order] is important.
Prisma Cloud evaluates the rule list from top to bottom until it finds a match based on the object filters.

By default, Prisma Cloud optimizes resource usage by only scanning images with running containers.
Therefore, you might not see a scan report for an image when it's first pulled into your environment unless it's been run. Note that images for short-lived containers are not scanned.
To scan all images on the hosts in your environment, go to *Manage > System > Scan*, set *Only scan images with running containers* to *Off*, and click *Save*.

To create a vulnerability rule:

[.procedure]
. Open Console.

. Go to *Defend > Vulnerabilities > {Images | Hosts | Functions}*.

. Click *Add rule*.

. Enter a rule name and configure the rule.
Configuration options are discussed in the following sections.

. Click *Save*.

. View the impact of your rule.
Go to *Monitor > Vulnerabilities* to view the scan reports.


=== Severity-based actions

Vulnerability rules let you specify trigger thresholds for alerting and blocking.
Alert and block actions let you establish quality gates in the CD segment of your continuous integration (CI) continuous deployment (CD) pipeline.

Alert and block thresholds can be set to different values.
The block threshold, however, must always be equal to or greater than the alert threshold.

image::vuln_management_rules_thresholds.png[width=700]

Setting the alert threshold to off allows all vulnerabilities for the resources in scope (as defined by your filters).
Practically, resource nodes in Radar turn green (no issues to report), and scan reports are empty (no issues to report).

When you create a xref:../technology_overviews/defender_architecture.adoc#_blocking_rules[blocking rule], Defender automatically installs itself as the final arbiter of all container lifecycle commands.
This way, the Defender can assess a Docker command, your current policy, and the status of an image before either forwarding the command to runC for execution, or blocking it all together.


=== Scope

The scope field lets you target rule to specific resources in your environment.
The scope of a rule is defined by referencing one or more collections.
By default, the scope is set to the *All* collection, which applies the rule globally.
For more information about creating and managing collections, see xref:../configure/collections.adoc[here].

image::vuln_management_rules_filters.png[width=700]


=== Vendor fixes

Rules can be applied conditionally depending on whether vendor fixes are available.
For example, you could tune your policy to block the deployment of containers with a critical vulnerability _*only if*_ the vulnerable package has an update that resolves the issue.
Otherwise, the deployment would be allowed to proceed.

Some vulnerabilities have a vendor status of "Will not fix".
This status is applied when vendors don't intend to resolve a vulnerability because it poses no significant risk to your environment.


=== Rule exceptions

You can configure Prisma Cloud to:

* Alert or block on specific CVEs or tags (deny).
* Ignore specific CVEs or tags (allow).

Under *Advanced settings*, create a list of vulnerabilities and tags, and specify how the scanner should handle them.
Leaving the expiration date blank enforces the action until the CVE or tag is removed from the list.
If you set an expiration date, and the current date is later than the expiration date, the scanner ignores the directive.
The CVE or tag remains in the list even if it's expired. It must be manually removed.
Notice that for tag exceptions, in case of a conflict (a vulnerability with two tags or more that have different actions in the rule exceptions) there's no guarantee what action will apply.

image::vuln_management_rules_exceptions.png[width=700]


=== Custom terminal output

Prisma Cloud lets you create rules that block access to resources or block the deployment of vulnerable containers.
For example, you might create a rule that blocks the deployment of any image that has critical severity vulnerabilities.
By default, when you try to run a vulnerable image, Prisma Cloud returns a terse response:

  $ docker run -it ubuntu:14.04 sh
  docker: Error response from daemon: [Prisma Cloud] Image operation blocked by policy: (sdf), has 44 vulnerabilities, [low:25 medium:19].

To help the operator better understand how to handle a blocked action, you can enhance Prisma Cloudâ€™s default response by:

* Appending a custom message to the default message.
For example, you could tell operators where to go to open a ticket.

* Configuring Prisma Cloud to return an itemized list of compliance issues rather than just a summary.
This way, the operator does not need to contact the security team to determine which issues are preventing deployment.
They are explicitly listed in the response.

When terminal output verbosity is set to *Detailed*, the response looks as follows:

  $ docker run -it ubuntu:14.04 sh
  docker: Error response from daemon: [Prisma Cloud] Image operation blocked by policy: (sdf), has 44 vulnerabilities, [low:25 medium:19].
  Image          ID       CVE             Package   Version             Severity   Status
  =====          ==       ===             =======   =======             ========   ======
  ubuntu:14.04   4333f1   CVE-2017-2518   sqlite3   3.8.2-1ubuntu2.1    medium     deferred
  ubuntu:14.04   4333f1   CVE-2017-6512   perl      5.18.2-2ubuntu1.1   medium     needed
  .
  .
  .


=== Grace period

Grace periods temporarily override the blocking action of a rule when new vulnerabilities are found. 
Grace periods give you time to address a vulnerability without compromising the availability of your app.
You can configure a uniform grace period for all severities or provide different settings for each severity.

When grace periods are configured, alerts trigger as normal, notifying you that a vulnerability exists in your environment.
The block action is suppressed for the number of days specified, giving you time to mitigate the vulnerability.

The start time for the grace period is the date the vulnerability was fixed.
The end time is the fixed date plus the number of days configured for the grace period.
If there is no fix for the vulnerability, then the start time for the grace period is the date the vulnerability was published/disclosed.

The following diagram shows how Prisma Cloud Defender responds to a vulnerability discovered in your environment.
Assume you have a vulnerability rule that blocks the deployment of any image with critical vulnerabilities, and the grace period is 30 days.

image::vuln_management_rules_grace_period.png[width=700]

* T~1~ -- The image has passed the security gates in your CI pipeline.
It has no critical vulnerabilities, so it's pushed to the registry.
* T~1~ - T~2~ -- The orchestrator runs the image in your cluster.
The image has no critical vulnerabilities, so Defender allows it to run.
* T~2~ -- Prisma Cloud Intelligence Stream acquires new threat data that identifies a critical vulnerability in the image.
The package vendor released a fix as soon as the vulnerability was disclosed.
In the next scan (by default, scans run every 24 hours), Prisma Cloud reports the vulnerability, and raises an alert if alerts are configured in the vulnerability rule.
* T~2~ - T~grace_period~ -- Prisma Cloud temporarily overrides the block rule, while the dev team addresses the vulnerability.
The orchestrator can continue to pull copies of the image into your environment and run it.
* T~grace_period~ -- Grace period expires.
If the vulnerability has not been fixed yet, Prisma Cloud blocks any new deployments of the image from this time forward.

Grace periods are a policy setting that's available for all components that enforce vulnerability policy, namely Defender, twistcli, and the Jenkins plugin.
In order to surface the issue as early as possible in the development lifecycle, you can specify a grace period in the CI pipeline.
For example, this control would let you fail image builds that have critical vulnerabilities that were fixed over 30 days ago.


[.task]
==== Configure grace period

The following procedure describes how to configure grace periods for blocking actions: 

[.procedure]
. In Console, go to *Defend > Vulnerabilities > Images > Deployed*.

. Select an existing rule or create a new rule with the *Add rule* button.

. Enter a rule name, notes, and scope.

. Under *Severity based actions*:

.. Select the desired *Alert threshold*

.. Select the desired *Block threshold*.
+
The block threshold must be equal to or greater than the alert threshold.
You must define a block threshold in order to configure grace period.

.. Configure the *Block grace period*:

... Select whether you would like to define the same grace period for *All severities* or grace period *By severity*.

... Specify the number of days.
Note that in case of *By severity* grace period you will be able to specify the number of days only for the severities that can be blocked.
Values that are not set will be set to 0. 
+
image::vuln_management_rules_grace_period_by_severity.png[width=700]
+
NOTE: Use the same procedure to configure grace periods to fail builds in your CI/CD pipeline.
To configure CI/CD pipeline vulnerability scanning rules, go to *Defend > Vulnerabilities > Images > CI*.


==== Elapsed time

All scan reports show whether a vulnerability has been fixed (fix status) and when it was fixed (fix date), and the time remaining in the grace period.
Scan reports are available from the:

* Console UI.
* Console UI as a CSV download.
* API (JSON or CSV).
* Jenkins plugin.
* twistcli.

The following example screenshot shows how the status of grace periods is displayed.
Grace periods are either still in force or expired.
For grace periods in force, the number of days remaining in the grace period is displayed.
For grace periods that have expired, the number of days since they expired is displayed.
Scan reports for running images can be retrieved from *Monitor > Vulnerabilities > Images > Deployed*.

image::vuln_management_rules_grace_period_remaining_time.png[width=700]

The following screenshot shows how the data is represented in the CSV scan report:

image::vuln_management_rules_grace_period_csv_scan_report.png[width=800]


[.task]
=== Blocking based on vulnerability severity

This example shows you how to create and test a rule that blocks the deployment of images with critical or high severity vulnerabilities.

[.procedure]
. In Console, go to *Defend > Vulnerabilities > Images*.

. Click *Add rule*.

.. Enter a rule name, such as *my-rule*.

.. In the *Severity based actions* table, set both the *Alert threshold* and *Block threshold* to *High*.

.. Target the rule to a very specific image.
In the *Images* filter, delete the wildcard, and enter *nginx{asterisk}*.

.. Click *Save*.

. Validate your policy by pulling down the nginx image and running it.

.. SSH to a host protected by Defender.

.. Pull the nginx:1.14 image.

  $ docker pull nginx:1.14

.. Run the nginx image.

  $ docker run -it nginx:1.14 /bin/sh
  docker: Error response from daemon: oci runtime error: [Prisma Cloud] Image operation blocked by policy: my-rule, has 7 vulnerabilities, [high:7].

.. Review the scan report for nginx:1.14.
Go to *Monitor > Vulnerabilities > Images*, and click on the entry for nginx:1.14.
You'll see a number of high severity vulnerabilities.
+
By default, Prisma Cloud optimizes resource usage by only scanning images with running containers.
Therefore, you won't see a scan report for ngninx until it's run.
+
image::vuln_management_rules_scan_report.png[width=700]

.. Review the audit (alert) for the block action.
Go to *Monitor > Events*, then click on *Docker*.
+
image::vuln_management_rules_block_audit.png[width=700]


[.task]
=== Blocking specific CVEs

This example shows you how to create and test a rule that blocks images with a specific CVE.

[.procedure]
. In Console, go to *Defend > Vulnerabilities > Images*.

. Click *Add rule*.

.. Enter a rule name, such as *my-rule2*.

.. Click *Advanced settings*.

.. In *Exceptions*, click *Add Exception*.

.. In *CVE*, enter *CVE-2018-8014*.
+
NOTE: You can find specific CVE IDs in the image scan reports.
Go to *Monitor > Vulnerabilities > Images*, select an image, then click *Show details* in each row.

.. In *Effect*, select *Block*.

.. Click *Add*.

.. Click *Save*.

. Try running an image with the CVE that you've explicitly denied.

  $ docker run -it imiell/bad-dockerfile:latest /bin/sh
  docker: Error response from daemon: oci runtime error: [Prisma Cloud] Image operation blocked by policy: my-rule2, has specific CVE CVE-2018-8014


=== Ignoring specific CVEs

Follow the same procedure as above, but set the action to *Ignore* instead of *Block*.
This will allow any CVE ID that you've defined in the rule, and lets you run images containing those CVEs in your environment.
