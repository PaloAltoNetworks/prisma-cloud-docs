== Containers with added capability are allowed
// Containers with added capability allowed


=== Policy Details 

[width=45%]
[cols="1,1"]
|=== 
|Prisma Cloud Policy ID 
| 54f07020-c973-43a4-9ac4-fce8b8f342f6

|Checkov Check ID 
| https://github.com/bridgecrewio/checkov/tree/master/checkov/terraform/checks/resource/kubernetes/AllowedCapabilitiesPSP.py[CKV_K8S_24]

|Severity
|LOW

|Subtype
|Build

|Frameworks
|Kubernetes, Terraform, Helm, Kustomize

|=== 



=== Description 


Using the Linux capabilities feature you can grant certain privileges to a process without granting all the privileges of the root user.
Added capabilities entitle containers in a pod with additional privileges that can be used to change core processes and networking settings of a cluster.
We recommend you only use privileges that are required for the proper function of the cluster.
To add or remove Linux capabilities for a container, you can include the capabilities field in the *securityContext* section of the container manifest.

=== Fix - Buildtime


*Kubernetes* 


* *Resources:* PodSecurityPolicy
* *Arguments:* allowedCapabilities (Optional)  Provides a list of capabilities that may be added to a container beyond the default set.


[source,yaml]
----
{
  "codes": [
    {
      "code": "apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: &lt;policy name>
spec:
- allowedCapabilities:",
      "language": "yaml"
    }
  ]
}
----
To use a **PodSecurityPolicy** resource, the requesting user or target pod's service account must be authorized to use the policy.
The preferred method is to grant access to the service account.
In the following example we use **RBAC**, a standard Kubernetes authorization mode.+++&lt;/policy>+++
A *Role* or *ClusterRole* needs to grant access to *use* the desired policies.
*Kind*: ClusterRole


[source,yaml]
----
{
  "codes": [
    {
      "code": "apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: &lt;role name>
rules:
- apiGroups: ['policy']
  resources: ['podsecuritypolicies']
  verbs:     ['use']
  resourceNames:
  - &lt;policy name>",
      "language": "yaml"
    }
  ]
}
----
The **ClusterRole** is then bound to the authorized service(s):+++&lt;/policy>++++++&lt;/role>+++
*Kind*: ClusterRoleBinding


[source,yaml]
----
{
  "codes": [
    {
      "code": "apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: &lt;binding name>
roleRef:
  kind: ClusterRole
  name: &lt;role name>
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: &lt;authorized service account name>
  namespace: &lt;authorized pod namespace>",
      "language": "yaml"
    }
  ]
}
----
