== Jenkins Maven project

Create a Maven project that builds a Docker image and then scans it for vulnerability and compliance issues.

[.task]
=== Configuring Maven

Configure Maven.

[.procedure]
. Go to the Jenkins top page.

. Click Manage Jenkins.

. Select Global Tool Configuration.

. Scroll down to the Maven section (Not Maven Configuration), and click Add Maven.
+
image::jenkins_maven_project_770273.png[width=400]


[.task]
=== Setting up a Maven project for container images

Set up a Jenkins Maven project.

[.procedure]
. Go to the Jenkins top page.

. Create a new project.

.. Click *New Item*.

.. In *Item* name, enter a name for your project.

.. Select *Maven project*.

.. Click *OK*.

. Add a build step.

.. Scroll down to the *Pre steps* section.

.. In the *Add pre-build step* drop-down list, select *Execute shell*.
+
image::jenkins_maven_project_770276.png[width=800]

.. In the *Command* text box, enter the following:
+
[source,bash]
----
echo "Creating Dockerfile..."
echo "FROM imiell/bad-dockerfile:latest" > Dockerfile
echo 'docker build --no-cache -t test/test-image:0.1 .' > build_image.sh
chmod +x build_image.sh

echo "Creating POM file..."
cat > pom.xml << EOF
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>groupId</groupId>
  <artifactId>artifactid</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>jar</packaging>
  <name>projectName</name>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>
  <build>

    <plugins>
      <plugin>
        <artifactId>exec-maven-plugin</artifactId>
        <groupId>org.codehaus.mojo</groupId>
        <executions>
          <execution>
            <id>Build Image</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>exec</goal>
            </goals>
            <configuration>
              <executable>build_image.sh</executable>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
EOF
----

. Add a build step that scans the container image(s) for vulnerabilities.

.. In the *Add build step* drop-down list, select *Scan Prisma Cloud Images*.

.. In the *Image* field, select the image to scan by specifying the repository and tag.
+
Use xref:../configure/rule_ordering_pattern_matching.adoc#[pattern matching expressions].
For example, enter `test/test-image*`.
+
NOTE: If the image you want to scan is created outside of this build, or if you want to scan the image every build, even if the build might not generate an new image, then click *Advanced*, and select xref:../continuous_integration/jenkins_plugin.adoc#_ignore_image_creation_time[*Ignore image creation time*].

. Add a post-build action so that image scan results in Jenkins directly.
+
This post-build step depends on a file generated by the previous scan build step, which holds the scan results.
This step specifically makes the results available for review in the Jenkins build tool.
Note that the previous scan step already published the results in Console, and they're ready to be reviewed there.

.. Scroll down to *Post-build Actions*.

.. In the *Add post-build action* drop-down menu, select *Publish Prisma Cloud analysis results*.

.. In the *Scan Result Files* field, accept the default.
+
Scan result files aren't deleted by the publish step.
They stay in the workspace.

. Click *Save*.

. Click *Build Now*.

. After the build completes, examine the results.
Scan reports are available in the following locations:
+
* Prisma Cloud Console:
Log into Console, and go to *Monitor > Vulnerabilities > Images > CI*.
* Jenkins:
Drill down into the build job, then click *Image Vulnerabilities* to see a detailed report.
+
image::jenkins_dashboard_scan_results.png[width=800]


=== Setting up a Maven project for serverless functions

The procedure for setting up Jenkins to scan serverless functions is similar to the procedure for container images, except you should use the *Scan Prisma Cloud Functions* build step.

image::jenkins_plugin_scan_functions_build_step.png[width=600]

Where:

* *Function Path* --
Path to the ZIP archive of the function to scan.
* *Function Name* --
(Optional) String identifier for matching policy rules in Console with the functions being scanned.
When creating policy rules in Console, you can target specific rules to specific functions by function name.
If this field is left unspecified, the plugin matches the function to the first rule where the function name is a wildcard.
* *AWS CloudFormation template file* --
(Optional) Path to CloudFormation template file in either JSON or YAML format.
Prisma Cloud scans the function source code for AWS service APIs being used, compares the APIs being used to the function permissions, and reports when functions have permissions for APIs they don't need.

After a build completes, you can view the scan reports in the following locations:

* Prisma Cloud Console:
Log into Console, and go to *Monitor > Vulnerabilities > Functions > CI*.

* Jenkins:
Drill down into the build job, then click *Vulnerabilities* to see a detailed report.
